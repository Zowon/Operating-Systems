// Question: Distributed Event Management System 
// NUTEC at FAST Peshawar is a large-scale event that involves multiple competitions across various domains. To manage this event efficiently, a Distributed Event Management System needs to be designed. This system will consist of multiple processes, each handling a specific aspect of the event. Communication between these processes will be facilitated using pipes, ensuring synchronized and seamless operations.
// The system should include the following processes:
// Event Registration Process (ER1): Responsible for collecting participant details from a file and forwarding them to the Scheduling Process.
// Scheduling Process (ER2): Receives participant details from ER1, assigns competition slots based on participant preferences, and forwards the schedule to the Venue Management Process.
// Venue Management Process (ER3): Receives schedules from ER2, maps the competitions to available venues, and sends the finalized schedule to the Broadcasting Process.
// Broadcasting Process (ER4): Receives the finalized schedule from ER3 and generates announcements for the event in the form of files.
// Requirements:
// Use fork() to create the four processes: ER1, ER2, ER3, and ER4.
// Ensure pipe communication between the processes for efficient data transfer.
// Implement proper synchronization to avoid data inconsistency.
// The output should include:
// Participant details forwarded by ER1.
// Schedules generated by ER2.
// Venue assignments by ER3.
// Announcements by ER4.
// Bonus (Optional):
// Implement error handling to ensure that:
// Files for participant details or venues are present.
// All pipes are closed properly after use.


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_FILES 5
#define BUFFER_SIZE 256

void PV1(int pipe_fd[]) {
    // Close unused read end
    close(pipe_fd[0]);

    // Example video files
    const char* video_files[MAX_FILES] = {"video1.mp4", "video2.mp4", "video3.mp4", "video4.mp4", "video5.mp4"};

    // Send file names to PV2
    for (int i = 0; i < MAX_FILES; i++) {
        write(pipe_fd[1], video_files[i], strlen(video_files[i]) + 1);
        printf("PV1: Sent %s to PV2\n", video_files[i]);
    }

    // Close write end
    close(pipe_fd[1]);
    exit(0);
}

void PV2(int pipe_fd1[], int pipe_fd2[]) {
    char buffer[BUFFER_SIZE];

    // Close unused write end of pipe 1 and unused read end of pipe 2
    close(pipe_fd1[1]);
    close(pipe_fd2[0]);

    while (read(pipe_fd1[0], buffer, BUFFER_SIZE) > 0) {
        // Transcode the file
        char transcoded_file[BUFFER_SIZE];
        snprintf(transcoded_file, BUFFER_SIZE, "%s_transcoded", buffer);
        printf("PV2: Transcoded %s to %s\n", buffer, transcoded_file);

        // Send transcoded file name to PV3
        write(pipe_fd2[1], transcoded_file, strlen(transcoded_file) + 1);
    }

    // Close pipes
    close(pipe_fd1[0]);
    close(pipe_fd2[1]);
    exit(0);
}

void PV3(int pipe_fd2[], int pipe_fd3[]) {
    char buffer[BUFFER_SIZE];

    // Close unused write end of pipe 2 and unused read end of pipe 3
    close(pipe_fd2[1]);
    close(pipe_fd3[0]);

    while (read(pipe_fd2[0], buffer, BUFFER_SIZE) > 0) {
        // Perform quality control
        char qc_passed_file[BUFFER_SIZE];
        snprintf(qc_passed_file, BUFFER_SIZE, "%s_QC_Passed", buffer);
        printf("PV3: Validated %s to %s\n", buffer, qc_passed_file);

        // Send validated file to PV4
        write(pipe_fd3[1], qc_passed_file, strlen(qc_passed_file) + 1);
    }

    // Close pipes
    close(pipe_fd2[0]);
    close(pipe_fd3[1]);
    exit(0);
}

void PV4(int pipe_fd[]) {
    char buffer[BUFFER_SIZE];

    // Close unused write end
    close(pipe_fd[1]);

    while (read(pipe_fd[0], buffer, BUFFER_SIZE) > 0) {
        // Distribute file
        printf("PV4: Distributed %s to the platform\n", buffer);
    }

    // Close read end
    close(pipe_fd[0]);
    exit(0);
}

int main() {
    int pipe_fd1[2], pipe_fd2[2], pipe_fd3[2];

    // Create pipes
    if (pipe(pipe_fd1) == -1 || pipe(pipe_fd2) == -1 || pipe(pipe_fd3) == -1) {
        perror("Pipe creation failed");
        exit(1);
    }

    // Create processes
    if (fork() == 0) {
        // PV1: Input Process
        PV1(pipe_fd1);
    } else if (fork() == 0) {
        // PV2: Transcoding Process
        PV2(pipe_fd1, pipe_fd2);
    } else if (fork() == 0) {
        // PV3: Quality Control Process
        PV3(pipe_fd2, pipe_fd3);
    } else if (fork() == 0) {
        // PV4: Distribution Process
        PV4(pipe_fd3);
    }

    // Close all pipes in the parent process
    close(pipe_fd1[0]);
    close(pipe_fd1[1]);
    close(pipe_fd2[0]);
    close(pipe_fd2[1]);
    close(pipe_fd3[0]);
    close(pipe_fd3[1]);

    // Wait for child processes to complete
    for (int i = 0; i < 4; i++) {
        wait(NULL);
    }

    printf("Distributed Video Processing System: All processes completed.\n");
    return 0;
}
