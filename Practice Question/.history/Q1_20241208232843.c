// Question: Distributed Event Management System 
// NUTEC at FAST Peshawar is a large-scale event that involves multiple competitions across various domains. To manage this event efficiently, a Distributed Event Management System needs to be designed. This system will consist of multiple processes, each handling a specific aspect of the event. Communication between these processes will be facilitated using pipes, ensuring synchronized and seamless operations.
// The system should include the following processes:
// Event Registration Process (ER1): Responsible for collecting participant details from a file and forwarding them to the Scheduling Process.
// Scheduling Process (ER2): Receives participant details from ER1, assigns competition slots based on participant preferences, and forwards the schedule to the Venue Management Process.
// Venue Management Process (ER3): Receives schedules from ER2, maps the competitions to available venues, and sends the finalized schedule to the Broadcasting Process.
// Broadcasting Process (ER4): Receives the finalized schedule from ER3 and generates announcements for the event in the form of files.
// Requirements:
// Use fork() to create the four processes: ER1, ER2, ER3, and ER4.
// Ensure pipe communication between the processes for efficient data transfer.
// Implement proper synchronization to avoid data inconsistency.
// The output should include:
// Participant details forwarded by ER1.
// Schedules generated by ER2.
// Venue assignments by ER3.
// Announcements by ER4.
// Bonus (Optional):
// Implement error handling to ensure that:
// Files for participant details or venues are present.
// All pipes are closed properly after use.


// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include <unistd.h>

// #define MAX_FILES 5
// #define BUFFER_SIZE 256

// void PV1(int pipe_fd[]) {
//     // Close unused read end
//     close(pipe_fd[0]);

//     // Example video files
//     const char* video_files[MAX_FILES] = {"video1.mp4", "video2.mp4", "video3.mp4", "video4.mp4", "video5.mp4"};

//     // Send file names to PV2
//     for (int i = 0; i < MAX_FILES; i++) {
//         write(pipe_fd[1], video_files[i], strlen(video_files[i]) + 1);
//         printf("PV1: Sent %s to PV2\n", video_files[i]);
//     }

//     // Close write end
//     close(pipe_fd[1]);
//     exit(0);
// }

// void PV2(int pipe_fd1[], int pipe_fd2[]) {
//     char buffer[BUFFER_SIZE];

//     // Close unused write end of pipe 1 and unused read end of pipe 2
//     close(pipe_fd1[1]);
//     close(pipe_fd2[0]);

//     while (read(pipe_fd1[0], buffer, BUFFER_SIZE) > 0) {
//         // Transcode the file
//         char transcoded_file[BUFFER_SIZE];
//         snprintf(transcoded_file, BUFFER_SIZE, "%s_transcoded", buffer);
//         printf("PV2: Transcoded %s to %s\n", buffer, transcoded_file);

//         // Send transcoded file name to PV3
//         write(pipe_fd2[1], transcoded_file, strlen(transcoded_file) + 1);
//     }

//     // Close pipes
//     close(pipe_fd1[0]);
//     close(pipe_fd2[1]);
//     exit(0);
// }

// void PV3(int pipe_fd2[], int pipe_fd3[]) {
//     char buffer[BUFFER_SIZE];

//     // Close unused write end of pipe 2 and unused read end of pipe 3
//     close(pipe_fd2[1]);
//     close(pipe_fd3[0]);

//     while (read(pipe_fd2[0], buffer, BUFFER_SIZE) > 0) {
//         // Perform quality control
//         char qc_passed_file[BUFFER_SIZE];
//         snprintf(qc_passed_file, BUFFER_SIZE, "%s_QC_Passed", buffer);
//         printf("PV3: Validated %s to %s\n", buffer, qc_passed_file);

//         // Send validated file to PV4
//         write(pipe_fd3[1], qc_passed_file, strlen(qc_passed_file) + 1);
//     }

//     // Close pipes
//     close(pipe_fd2[0]);
//     close(pipe_fd3[1]);
//     exit(0);
// }

// void PV4(int pipe_fd[]) {
//     char buffer[BUFFER_SIZE];

//     // Close unused write end
//     close(pipe_fd[1]);

//     while (read(pipe_fd[0], buffer, BUFFER_SIZE) > 0) {
//         // Distribute file
//         printf("PV4: Distributed %s to the platform\n", buffer);
//     }

//     // Close read end
//     close(pipe_fd[0]);
//     exit(0);
// }

// int main() {
//     int pipe_fd1[2], pipe_fd2[2], pipe_fd3[2];

//     // Create pipes
//     if (pipe(pipe_fd1) == -1 || pipe(pipe_fd2) == -1 || pipe(pipe_fd3) == -1) {
//         perror("Pipe creation failed");
//         exit(1);
//     }

//     // Create processes
//     if (fork() == 0) {
//         // PV1: Input Process
//         PV1(pipe_fd1);
//     } else if (fork() == 0) {
//         // PV2: Transcoding Process
//         PV2(pipe_fd1, pipe_fd2);
//     } else if (fork() == 0) {
//         // PV3: Quality Control Process
//         PV3(pipe_fd2, pipe_fd3);
//     } else if (fork() == 0) {
//         // PV4: Distribution Process
//         PV4(pipe_fd3);
//     }

//     // Close all pipes in the parent process
//     close(pipe_fd1[0]);
//     close(pipe_fd1[1]);
//     close(pipe_fd2[0]);
//     close(pipe_fd2[1]);
//     close(pipe_fd3[0]);
//     close(pipe_fd3[1]);

//     // Wait for child processes to complete
//     for (int i = 0; i < 4; i++) {
//         wait(NULL);
//     }

//     printf("Distributed Video Processing System: All processes completed.\n");
//     return 0;
// }



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BUFFER_SIZE 256
#define MAX_PARTICIPANTS 5

void ER1(int pipe_fd[]) {
    // Close the unused read end of the pipe
    close(pipe_fd[0]);

    // Example participant details
    const char *participants[MAX_PARTICIPANTS] = {
        "Participant1: AI Competition",
        "Participant2: Web Development",
        "Participant3: Cybersecurity",
        "Participant4: Gaming",
        "Participant5: Robotics"};

    // Send participant details to ER2
    for (int i = 0; i < MAX_PARTICIPANTS; i++) {
        write(pipe_fd[1], participants[i], strlen(participants[i]) + 1);
        printf("ER1: Sent participant details - %s\n", participants[i]);
    }

    // Close the write end of the pipe
    close(pipe_fd[1]);
    exit(0);
}

void ER2(int pipe_fd1[], int pipe_fd2[]) {
    char buffer[BUFFER_SIZE];

    // Close the unused write end of pipe 1 and unused read end of pipe 2
    close(pipe_fd1[1]);
    close(pipe_fd2[0]);

    // Read participant details from ER1
    while (read(pipe_fd1[0], buffer, BUFFER_SIZE) > 0) {
        // Create a schedule
        char schedule[BUFFER_SIZE];
        strcpy(schedule, buffer); // Copy participant details
        strcat(schedule, " -> Slot Assigned"); // Append schedule details
        printf("ER2: Generated schedule - %s\n", schedule);

        // Send the schedule to ER3
        write(pipe_fd2[1], schedule, strlen(schedule) + 1);
    }

    // Close pipes
    close(pipe_fd1[0]);
    close(pipe_fd2[1]);
    exit(0);
}

void ER3(int pipe_fd2[], int pipe_fd3[]) {
    char buffer[BUFFER_SIZE];

    // Close the unused write end of pipe 2 and unused read end of pipe 3
    close(pipe_fd2[1]);
    close(pipe_fd3[0]);

    // Read schedules from ER2
    while (read(pipe_fd2[0], buffer, BUFFER_SIZE) > 0) {
        // Assign a venue
        char venue_schedule[BUFFER_SIZE];
        strcpy(venue_schedule, buffer); // Copy schedule details
        strcat(venue_schedule, " -> Venue Assigned"); // Append venue details
        printf("ER3: Mapped to venue - %s\n", venue_schedule);

        // Send the finalized schedule to ER4
        write(pipe_fd3[1], venue_schedule, strlen(venue_schedule) + 1);
    }

    // Close pipes
    close(pipe_fd2[0]);
    close(pipe_fd3[1]);
    exit(0);
}

void ER4(int pipe_fd[]) {
    char buffer[BUFFER_SIZE];

    // Close the unused write end of the pipe
    close(pipe_fd[1]);

    // Read finalized schedules from ER3
    while (read(pipe_fd[0], buffer, BUFFER_SIZE) > 0) {
        // Generate an announcement
        printf("ER4: Announcement generated - %s\n", buffer);
    }

    // Close the read end of the pipe
    close(pipe_fd[0]);
    exit(0);
}

int main() {
    int pipe_fd1[2], pipe_fd2[2], pipe_fd3[2];

    // Create pipes
    if (pipe(pipe_fd1) == -1 || pipe(pipe_fd2) == -1 || pipe(pipe_fd3) == -1) {
        perror("Pipe creation failed");
        exit(1);
    }

    // Create processes
    if (fork() == 0) {
        // ER1: Event Registration Process
        ER1(pipe_fd1);
    } else if (fork() == 0) {
        // ER2: Scheduling Process
        ER2(pipe_fd1, pipe_fd2);
    } else if (fork() == 0) {
        // ER3: Venue Management Process
        ER3(pipe_fd2, pipe_fd3);
    } else if (fork() == 0) {
        // ER4: Broadcasting Process
        ER4(pipe_fd3);
    }

    // Close all pipes in the parent process
    close(pipe_fd1[0]);
    close(pipe_fd1[1]);
    close(pipe_fd2[0]);
    close(pipe_fd2[1]);
    close(pipe_fd3[0]);
    close(pipe_fd3[1]);

    // Wait for child processes to complete
    for (int i = 0; i < 4; i++) {
        wait(NULL);
    }

    printf("Distributed Event Management System: All processes completed.\n");
    return 0;
}
